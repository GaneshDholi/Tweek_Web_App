// language chagnes
const translations = {
  en: {
    translation: {
      // --- Weekdays & Months ---
      "day.0": "Sunday", "day.1": "Monday", "day.2": "Tuesday", "day.3": "Wednesday", "day.4": "Thursday", "day.5": "Friday", "day.6": "Saturday",
      "dayShort.0": "Sun", "dayShort.1": "Mon", "dayShort.2": "Tue", "dayShort.3": "Wed", "dayShort.4": "Thu", "dayShort.5": "Fri", "dayShort.6": "Sat",
      "month.0": "January", "month.1": "February", "month.2": "March", "month.3": "April", "month.4": "May", "month.5": "June", "month.6": "July", "month.7": "August", "month.8": "September", "month.9": "October", "month.10": "November", "month.11": "December",

      // --- Main Menu ---
      "menu.language": "Language", "menu.about": "About", "menu.search": "Search", "menu.print": "Print", "menu.share": "Share", "menu.premium": "Go premium", "menu.support": "Support",

      // --- Task Modals ---
      "repeat.title": "Repeat Task", "repeat.none": "None", "repeat.daily": "Daily", "repeat.weekly": "Weekly", "repeat.monthly": "Monthly", "repeat.annually": "Annually",
      "more.tomorrow": "Tomorrow", "more.nextWeek": "Next week", "more.someday": "Someday", "more.duplicate": "Duplicate", "more.addFile": "Add file",
      "modal.taskTitle": "Task title...", "modal.addNotes": "Add some extra notes here...",

      // --- Share Modal ---
      "share.title": "Share Task Access", "share.description": "Add people to allow them to view all your tasks.", "share.emailPlaceholder": "Add people by email", "share.button": "Share", "share.sharedWith": "Shared With",

      // --- Auth Modal ---
      "auth.loginTitle": "Login to Your Account",
      "auth.registerTitle": "Create an Account",
      "auth.verifyTitle": "Verify Your Email",
      "auth.emailPlaceholder": "Enter your email",
      "auth.passwordPlaceholder": "Enter your password",
      "auth.firstNamePlaceholder": "First Name",
      "auth.lastNamePlaceholder": "Last Name",
      "auth.createPasswordPlaceholder": "Create a password",
      "auth.loginButton": "Login",
      "auth.loggingInButton": "Logging In...",
      "auth.registerButton": "Register",
      "auth.registeringButton": "Registering...",
      "auth.verifyButton": "Verify Account",
      "auth.verifyingButton": "Verifying...",
      "auth.registerToggle": "Don't have an account? Register",
      "auth.loginToggle": "Already have an account? Login",
      "auth.verifySuccess": "Account verified successfully! Please log in."
    }
  },
  es: {
    translation: {
      // --- Weekdays & Months ---
      "day.0": "Domingo", "day.1": "Lunes", "day.2": "Martes", "day.3": "Miércoles", "day.4": "Jueves", "day.5": "Viernes", "day.6": "Sábado",
      "dayShort.0": "Dom", "dayShort.1": "Lun", "dayShort.2": "Mar", "dayShort.3": "Mié", "dayShort.4": "Jue", "dayShort.5": "Vie", "dayShort.6": "Sáb",
      "month.0": "Enero", "month.1": "Febrero", "month.2": "Marzo", "month.3": "Abril", "month.4": "Mayo", "month.5": "Junio", "month.6": "Julio", "month.7": "Agosto", "month.8": "Septiembre", "month.9": "Octubre", "month.10": "Noviembre", "month.11": "Diciembre",

      // --- Main Menu ---
      "menu.language": "Idioma", "menu.about": "Acerca de", "menu.search": "Buscar", "menu.print": "Imprimir", "menu.share": "Compartir", "menu.premium": "Hazte premium", "menu.support": "Soporte",

      // --- Task Modals ---
      "repeat.title": "Repetir Tarea", "repeat.none": "Ninguna", "repeat.daily": "Diariamente", "repeat.weekly": "Semanalmente", "repeat.monthly": "Mensualmente", "repeat.annually": "Anualmente",
      "more.tomorrow": "Mañana", "more.nextWeek": "La próxima semana", "more.someday": "Algún día", "more.duplicate": "Duplicar", "more.addFile": "Añadir archivo",
      "modal.taskTitle": "Título de la tarea...", "modal.addNotes": "Añade algunas notas extra aquí...",

      // --- Share Modal ---
      "share.title": "Compartir Acceso a Tareas", "share.description": "Añade personas para permitirles ver todas tus tareas.", "share.emailPlaceholder": "Añadir personas por correo", "share.button": "Compartir", "share.sharedWith": "Compartido Con",

      // --- Auth Modal ---
      "auth.loginTitle": "Inicia Sesión en Tu Cuenta",
      "auth.registerTitle": "Crea Tu Cuenta",
      "auth.verifyTitle": "Verifica Tu Correo",
      "auth.emailPlaceholder": "Introduce tu correo electrónico",
      "auth.passwordPlaceholder": "Introduce tu contraseña",
      "auth.firstNamePlaceholder": "Nombre",
      "auth.lastNamePlaceholder": "Apellido",
      "auth.createPasswordPlaceholder": "Crea una contraseña",
      "auth.loginButton": "Iniciar Sesión",
      "auth.loggingInButton": "Iniciando Sesión...",
      "auth.registerButton": "Registrarse",
      "auth.registeringButton": "Registrando...",
      "auth.verifyButton": "Verificar Cuenta",
      "auth.verifyingButton": "Verificando...",
      "auth.registerToggle": "¿No tienes una cuenta? Regístrate",
      "auth.loginToggle": "¿Ya tienes una cuenta? Inicia Sesión",
      "auth.verifySuccess": "¡Cuenta verificada con éxito! Por favor, inicia sesión."
    }
  },
  hi: {
    translation: {
      // --- Weekdays & Months ---
      "day.0": "रविवार", "day.1": "सोमवार", "day.2": "मंगलवार", "day.3": "बुधवार", "day.4": "गुरुवार", "day.5": "शुक्रवार", "day.6": "शनिवार",
      "dayShort.0": "रवि", "dayShort.1": "सोम", "dayShort.2": "मंगल", "dayShort.3": "बुध", "dayShort.4": "गुरु", "dayShort.5": "शुक्र", "dayShort.6": "शनि",
      "month.0": "जनवरी", "month.1": "फ़रवरी", "month.2": "मार्च", "month.3": "अप्रैल", "month.4": "मई", "month.5": "जून", "month.6": "जुलाई", "month.7": "अगस्त", "month.8": "सितंबर", "month.9": "अक्टूबर", "month.10": "नवंबर", "month.11": "दिसंबर",

      // --- Main Menu ---
      "menu.language": "भाषा", "menu.about": "बारे में", "menu.search": "खोज", "menu.print": "प्रिंट", "menu.share": "शेयर", "menu.premium": "प्रीमियम बनें", "menu.support": "समर्थन",

      // --- Task Modals ---
      "repeat.title": "कार्य दोहराएं", "repeat.none": "कोई नहीं", "repeat.daily": "रोज़", "repeat.weekly": "साप्ताहिक", "repeat.monthly": "मासिक", "repeat.annually": "वार्षिक",
      "more.tomorrow": "कल", "more.nextWeek": "अगले सप्ताह", "more.someday": "किसी दिन", "more.duplicate": "डुप्लिकेट", "more.addFile": "फ़ाइल जोड़ें",
      "modal.taskTitle": "कार्य का शीर्षक...", "modal.addNotes": "यहाँ कुछ अतिरिक्त नोट्स जोड़ें...",

      // --- Share Modal ---
      "share.title": "कार्य पहुंच साझा करें", "share.description": "लोगों को आपके सभी कार्य देखने की अनुमति देने के लिए जोड़ें।", "share.emailPlaceholder": "ईमेल द्वारा लोगों को जोड़ें", "share.button": "शेयर", "share.sharedWith": "के साथ साझा",

      // --- Auth Modal ---
      "auth.loginTitle": "अपने खाते में प्रवेश करें",
      "auth.registerTitle": "अपना खाता बनाएं",
      "auth.verifyTitle": "अपना ईमेल सत्यापित करें",
      "auth.emailPlaceholder": "अपना ईमेल दर्ज करें",
      "auth.passwordPlaceholder": "अपना पासवर्ड दर्ज करें",
      "auth.firstNamePlaceholder": "पहला नाम",
      "auth.lastNamePlaceholder": "अंतिम नाम",
      "auth.createPasswordPlaceholder": "एक पासवर्ड बनाएं",
      "auth.loginButton": "लॉग इन करें",
      "auth.loggingInButton": "लॉग इन हो रहा है...",
      "auth.registerButton": "रजिस्टर करें",
      "auth.registeringButton": "पंजीकरण हो रहा है...",
      "auth.verifyButton": "खाता सत्यापित करें",
      "auth.verifyingButton": "सत्यापन हो रहा है...",
      "auth.registerToggle": "खाता नहीं है? रजिस्टर करें",
      "auth.loginToggle": "पहले से ही एक खाता है? लॉग इन करें",
      "auth.verifySuccess": "खाता सफलतापूर्वक सत्यापित हो गया! कृपया लॉग इन करें।"
    }
  },
  de: {
    translation: {
      // --- Weekdays & Months ---
      "day.0": "Sonntag", "day.1": "Montag", "day.2": "Dienstag", "day.3": "Mittwoch", "day.4": "Donnerstag", "day.5": "Freitag", "day.6": "Samstag",
      "dayShort.0": "So", "dayShort.1": "Mo", "dayShort.2": "Di", "dayShort.3": "Mi", "dayShort.4": "Do", "dayShort.5": "Fr", "dayShort.6": "Sa",
      "month.0": "Januar", "month.1": "Februar", "month.2": "März", "month.3": "April", "month.4": "Mai", "month.5": "Juni", "month.6": "Juli", "month.7": "August", "month.8": "September", "month.9": "Oktober", "month.10": "November", "month.11": "Dezember",

      // --- Main Menu ---
      "menu.language": "Sprache", "menu.about": "Über", "menu.search": "Suchen", "menu.print": "Drucken", "menu.share": "Teilen", "menu.premium": "Premium werden", "menu.support": "Unterstützung",

      // --- Task Modals ---
      "repeat.title": "Aufgabe wiederholen", "repeat.none": "Keine", "repeat.daily": "Täglich", "repeat.weekly": "Wöchentlich", "repeat.monthly": "Monatlich", "repeat.annually": "Jährlich",
      "more.tomorrow": "Morgen", "more.nextWeek": "Nächste Woche", "more.someday": "Eines Tages", "more.duplicate": "Duplizieren", "more.addFile": "Datei hinzufügen",
      "modal.taskTitle": "Aufgabentitel...", "modal.addNotes": "Hier einige zusätzliche Notizen hinzufügen...",

      // --- Share Modal ---
      "share.title": "Aufgabenzugriff teilen", "share.description": "Fügen Sie Personen hinzu, damit diese alle Ihre Aufgaben einsehen können.", "share.emailPlaceholder": "Personen per E-Mail hinzufügen", "share.button": "Teilen", "share.sharedWith": "Geteilt mit",

      // --- Auth Modal ---
      "auth.loginTitle": "Melden Sie sich bei Ihrem Konto an",
      "auth.registerTitle": "Erstelle deinen Account",
      "auth.verifyTitle": "Bestätige deine E-Mail-Adresse",
      "auth.emailPlaceholder": "Geben sie Ihre E-Mail Adresse ein",
      "auth.passwordPlaceholder": "Geben Sie Ihr Passwort ein",
      "auth.firstNamePlaceholder": "Vorname",
      "auth.lastNamePlaceholder": "Nachname",
      "auth.createPasswordPlaceholder": "Erstellen Sie ein Passwort",
      "auth.loginButton": "Anmeldung",
      "auth.loggingInButton": "Anmelden...",
      "auth.registerButton": "Registrieren",
      "auth.registeringButton": "Registrieren...",
      "auth.verifyButton": "Konto bestätigen",
      "auth.verifyingButton": "Überprüfen...",
      "auth.registerToggle": "Sie haben kein Konto? Registrieren",
      "auth.loginToggle": "Haben Sie bereits ein Konto? Anmelden",
      "auth.verifySuccess": "Konto erfolgreich bestätigt! Bitte melden Sie sich an."
    }
  }
};

const API_BASE_URL = "https://tweek-web-app-2.onrender.com";
let isLoggedIn = false;

let authSystem;
// 2. I18NEXT INITIALIZATION & MAIN LOGIC
document.addEventListener('DOMContentLoaded', () => {
  const languageTrigger = document.getElementById('language-menu-trigger');
  const languageSubmenu = document.querySelector('.language-submenu');

  if (languageTrigger) {
    languageTrigger.addEventListener('click', (event) => {
      // Prevent the link from trying to navigate
      event.preventDefault();
      // Stop the click from immediately being caught by the 'document' listener below
      event.stopPropagation();
      // Toggle the .open class on the submenu to show/hide it
      languageSubmenu.classList.toggle('open');
    });
  }

  // Add a listener to the whole document to close the menu when clicking anywhere else
  document.addEventListener('click', () => {
    if (languageSubmenu && languageSubmenu.classList.contains('open')) {
      languageSubmenu.classList.remove('open');
    }
  });

  // Update your existing i18next event listener to also close the menu after selection
  document.querySelectorAll('.language-submenu a').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const lang = e.target.getAttribute('data-lang');
      i18next.changeLanguage(lang, () => {
        // ... your existing updateContent() and renderDynamicCalendar() calls ...
        updateStaticContent();
        renderWeeklyView();
        // Add this line to close the menu
        if (languageSubmenu) {
          languageSubmenu.classList.remove('open');
        }
      });
    });
  });
  i18next.init({
    lng: 'en', // default language
    debug: false,
    resources: translations
  }).then(async () => {
    // This will translate all static text on page load
    updateStaticContent();
    // renderDynamicCalendar();

    authSystem = initializeAuthSystem();

    // await authSystem.checkLoginStatus();
    loadInitialView()
    // initializeApp();
  });

  async function loadInitialView() {
    // Wait to determine if the user is logged in or a guest
    await authSystem.checkLoginStatus();

    // Now that we know the login state, render the main view a single time.
    // This will fetch either guest tasks or user tasks correctly.
    renderWeeklyView();
  }

  // Function to translate all static text with data-i18n attributes
  function updateStaticContent() {
    // Define which keys contain HTML and need special handling.
    const keysWithHtml = ['auth.registerToggle', 'auth.loginToggle'];

    document.querySelectorAll('[data-i18n]').forEach(element => {
      const key = element.dataset.i18n;

      if (key.startsWith('[placeholder]')) {
        element.placeholder = i18next.t(key.substring('[placeholder]'.length));
      } else if (keysWithHtml.includes(key)) {
        // If the key is in our special list, use .innerHTML to render the link
        element.innerHTML = i18next.t(key);
      } else {
        // Otherwise, use the safer .textContent for all other text
        element.textContent = i18next.t(key);
      }
    });
  }



  // Add click listeners to the language links in the new submenu
  document.querySelectorAll('.language-submenu a').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const lang = e.target.getAttribute('data-lang');
      i18next.changeLanguage(lang, () => {
        updateStaticContent();
        // IMPORTANT: Re-render the calendar after language change
        renderDynamicCalendar();
      });
    });
  });
});

function renderDynamicCalendar() {
  const mainTitle = document.getElementById('monthwithyear');
  if (mainTitle) {
    const currentDate = new Date();

    const monthIndex = currentDate.getMonth();
    const year = currentDate.getFullYear();

    // Use i18next.t() to get the translated month name from the translations object
    const translatedMonth = i18next.t('month.' + monthIndex);

    mainTitle.textContent = `${translatedMonth} ${year}`;
  }

  // --- Example 2: Re-render the weekly view headers with translated day names ---
  const weeklyView = document.getElementById('weekly-view');
  if (weeklyView) {
    // ===> TODO: Replace this with your function that gets the days of the current week <===
    const daysInWeek = getDaysOfCurrentWeek();

    // It's often easiest to clear and rebuild the dynamic parts
    weeklyView.innerHTML = '';

    daysInWeek.forEach(dayDate => {
      const dayOfWeekIndex = dayDate.getDay(); // 0 for Sunday, 1 for Monday...

      // Get translated short day name
      const translatedDayShort = i18next.t('dayShort.' + dayOfWeekIndex);

      // ===> TODO: This is an EXAMPLE. Replace it with your actual HTML structure for a day column. <===
      const dayColumn = document.createElement('div');
      dayColumn.className = 'day-column-example'; // Use your own classes
      dayColumn.innerHTML = `
                <div class="day-header-example">
                    <span class="day-name">${translatedDayShort}</span>
                    <span class="day-number">${dayDate.getDate()}</span>
                </div>
                <div class="tasks-container">
                    <!-- Your tasks for this day would be rendered here -->
                </div>
            `;
      weeklyView.appendChild(dayColumn);
    });
  }

  console.log("Dynamic content has been re-rendered in:", i18next.language);
}

function getDaysOfCurrentWeek() {
  const today = new Date();
  // Adjust to make Monday the start of the week if needed
  const firstDayOfWeek = today.getDate() - today.getDay() + (today.getDay() === 0 ? -6 : 1);
  const startOfWeek = new Date(today.setDate(firstDayOfWeek));

  const week = [];
  for (let i = 0; i < 7; i++) {
    const day = new Date(startOfWeek);
    day.setDate(day.getDate() + i);
    week.push(day);
  }
  return week;
}

// You need to re-add the initializeApp function we created before
async function initializeApp() {
  if (isLoggedIn) {
    console.log("User is logged in. Fetching data...");
    renderWeeklyView(); // Or your main data-fetching function
    // fetchAndRenderCalendars(); // etc.
  } else {
    console.log("User is a guest. Rendering guest view.");
    renderWeeklyView(); // This will use guest tasks from localStorage
  }
}

// moths calander 
const months = [
  "January", "February", "March", "April", "May", "June",
  "July", "August", "September", "October", "November", "December"
];

const calendarContainer = document.getElementById("year-calendar");
const yearTitle = document.getElementById("year-title");
const prevBtn = document.getElementById("prev");
const nextBtn = document.getElementById("next");

let currentYear = new Date().getFullYear();

function renderYearCalendar(year) {
  calendarContainer.innerHTML = "";
  yearTitle.textContent = year;


  for (let month = 0; month < 12; month++) {
    const monthDiv = document.createElement("div");
    monthDiv.className = "month";

    const startDay = new Date(year, month, 1).getDay();
    const totalDays = new Date(year, month + 1, 0).getDate();
    const prevDays = new Date(year, month, 0).getDate();

    const today = new Date();
    const isCurrentYear = year === today.getFullYear();
    const isCurrentMonth = month === today.getMonth();

    if (isCurrentYear && isCurrentMonth) {
      monthDiv.id = "current-month";
    }


    let html = `<h3>${months[month]}</h3>
          <div class="days">
            <div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div>
            <div>Thu</div><div>Fri</div><div>Sat</div>
          </div>
          <ul class="dates">`;

    for (let i = startDay; i > 0; i--) {
      html += `<li class="inactive"> </li>`;
    }

    for (let d = 1; d <= totalDays; d++) {
      let isToday =
        isCurrentYear && isCurrentMonth && d === today.getDate();
      html += `<li class="${isToday ? "today" : ""}">${d}</li>`;
    }

    html += `</ul>`;
    monthDiv.innerHTML = html;
    calendarContainer.appendChild(monthDiv);

    const dateItems = monthDiv.querySelectorAll("li:not(.inactive)");
    dateItems.forEach((item) => {
      item.addEventListener("click", () => {
        document.querySelectorAll(".selected-date").forEach(el => {
          el.classList.remove("selected-date");
        });

        item.classList.add("selected-date");


        const monthStr = months[month];
        const fullDate = `${monthStr} ${year}`;

        const dayNumber = parseInt(item.textContent);

        const selectedDate = new Date(year, month, dayNumber);

        dayNumber.classlis

        openBtn.textContent = fullDate;
        openBtn.style.color = "";
        modal.style.display = "none";

        renderWeeklyView(selectedDate);
      });
    });
  }
}

prevBtn.addEventListener("click", () => {
  currentYear--;
  renderYearCalendar(currentYear);
});

nextBtn.addEventListener("click", () => {
  currentYear++;
  renderYearCalendar(currentYear);
});


const modal = document.getElementById("calendarModal");
const openBtn = document.getElementById("openCalendarBtn");
const closeBtn = document.getElementById("year-title");


let clickTimer = null;

openBtn.addEventListener("click", () => {
  clickTimer = setTimeout(() => {
    const today = new Date();
    const monthStr = months[today.getMonth()];
    const year = today.getFullYear();
    openBtn.textContent = `${monthStr} ${year}`;

    renderWeeklyView(today, today);
  }, 250);
});

openBtn.addEventListener("dblclick", () => {
  clearTimeout(clickTimer);
  modal.style.display = "block";
  renderYearCalendar(currentYear);

  setTimeout(() => {
    const currentMonthEl = document.getElementById("current-month");
    if (currentMonthEl) {
      currentMonthEl.scrollIntoView({ behavior: "smooth", block: "center" });
    }
  }, 100);
});




closeBtn.onclick = function () {
  modal.style.display = "none";
};

window.onclick = function (event) {
  if (event.target === modal) {
    modal.style.display = "none";
  }
};


renderYearCalendar(currentYear);

// This variable will hold the date of the currently displayed week.
let currentViewDate = new Date();

/**
 * @param {string} taskId - The ID of the task being moved.
 * @param {string|null} newDate - The ISO date string for the new column, or null.
 * @param {boolean} isSomeday - True if the task is dropped in the "Someday" section.
 */
async function handleTaskDrop(taskId, newDate, isSomeday) {
  const payload = {};

  if (isSomeday) {
    payload.isSomeday = true;
    payload.date = null; // Unset the date when moving a task to Someday
  } else {
    payload.isSomeday = false;
    payload.date = new Date(`${newDate}T12:00:00.000Z`).toISOString();
  }

  try {
    const response = await fetch(`https://tweek-web-app-2.onrender.com/api/tasks/${taskId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem("token")}`
      },
      credentials: 'include',
      // Only send the fields that are changing
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to update task on drop: ${errorText}`);
    }

    console.log(`Task ${taskId} moved successfully.`);
    // Re-render the entire view to show the change
    renderWeeklyView(currentViewDate);

  } catch (error) {
    console.error('Error handling task drop:', error);
    alert('Could not move the task. Please try again.');
  }
}

/**
 * Adds the necessary event listeners to an element to make it a valid drop zone.
 * @param {HTMLElement} element - The HTML element to turn into a drop zone.
 */
function addDropZoneListeners(element) {
  // Fired continuously while a draggable element is over the drop zone
  element.addEventListener('dragover', (e) => {
    e.preventDefault(); // This is crucial! It allows the 'drop' event to fire.
    element.classList.add('drag-over');
  });

  // Fired when a draggable element leaves the drop zone
  element.addEventListener('dragleave', () => {
    element.classList.remove('drag-over');
  });

  // Fired when a draggable element is dropped on the drop zone
  element.addEventListener('drop', async (e) => {
    e.preventDefault();
    element.classList.remove('drag-over');

    const taskId = e.dataTransfer.getData('text/plain');
    if (!taskId) return; // Exit if no task ID was transferred

    const newDate = element.dataset.dateColumn;
    const isSomeday = element.dataset.isSomeday === 'true';

    // Call the function to update the backend and re-render
    await handleTaskDrop(taskId, newDate, isSomeday);
  });
}

//weekdays
const weekContainer = document.getElementById("weekly-view");
const rootStyles = getComputedStyle(document.documentElement);
const primaryFont = rootStyles.getPropertyValue("--primary-font").trim();
let taskContainer = null;
let isRendering = false
async function renderWeeklyView(baseDate = new Date(), highlightDate = null) {
  if (isRendering) {
    console.warn("Blocking a duplicate render call.");
    return;
  }
  // FIX: Set the flag to true to block other calls.
  isRendering = true;

  try {
    currentViewDate = baseDate;
    const today = baseDate;
    const weekdays = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    const currentDate = new Date();

    // --- Month & Year Header ---
    const monthWithYear = document.getElementById("openCalendarBtn");
    const monthName = months[today.getMonth()];
    const year = today.getFullYear();
    monthWithYear.textContent = `${monthName} ${year}`;
    monthWithYear.style.color =
      currentDate.getMonth() !== today.getMonth() ||
        currentDate.getFullYear() !== today.getFullYear()
        ? "#5167f4"
        : "";
    monthWithYear.style.cursor = "pointer";

    // Reset container
    weekContainer.innerHTML = "";

    const firstRow = document.createElement("div");
    firstRow.className = "week-grid-row";

    const satSunColumn = document.createElement("div");
    satSunColumn.style.display = "flex";
    satSunColumn.style.flexDirection = "column";
    satSunColumn.style.gap = "40px";

    const monday = new Date(today);
    const dayOfWeek = monday.getDay(); // Sunday = 0, Monday = 1, ..., Saturday = 6

    // Calculate the difference to get to the previous Monday
    const diff = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    monday.setDate(today.getDate() + diff);

    // Set time to the beginning of the day to avoid timezone issues
    monday.setHours(0, 0, 0, 0);

    let tasksByDate = new Map();
    // Add this new helper function inside your renderWeeklyView function
    function balanceRows() {
      const weekdayColumns = Array.from(document.querySelectorAll(".day-box")).slice(0, 5);
      const todoLists = weekdayColumns.map(col => col.querySelector('.todo-list'));

      // 1. Find the maximum number of rows in any weekday column
      let maxRows = 0;
      todoLists.forEach(list => {
        if (list.children.length > maxRows) {
          maxRows = list.children.length;
        }
      });

      // 2. Ensure all weekday columns have the same number of rows
      todoLists.forEach(list => {
        while (list.children.length < maxRows) {
          const newBox = document.createElement("li");
          newBox.style.height = "40px";
          newBox.style.borderBottom = "1px solid #e0e0e0";
          list.appendChild(newBox);
        }
      });
    }

    // --- Helpers ---
    function createInput(styles = {}) {
      const input = document.createElement("input");
      input.type = "text";
      Object.assign(input.style, {
        border: "rgba(255,255,255,0.95)",
        fontSize: "14px",
        borderRadius: "6px",
        backgroundColor: "white",
        boxShadow: "0 4px 8px rgba(0,0,0,0.1)",
        outline: "none",
        height: "100%",
        marginTop: "0",
        boxSizing: "border-box",
        width: "100%",
        ...styles,
      });
      return input;
    }

    function styleTaskSpan(span, color) {
      span.style.whiteSpace = "nowrap";
      span.style.overflow = "hidden";
      span.style.textOverflow = "ellipsis";
      span.style.height = "18px";
      span.style.textAlign = "left";
      if (color) {
        span.style.backgroundColor = color;
      }
    }

    function createCheckBtn(span, task) {
      const btn = document.createElement("img");
      btn.src = "./assets/icons/check-button.png";
      btn.className = "check-btn";
      btn.title = "Mark as done / undone";
      Object.assign(btn.style, {
        width: "18px",
        height: "18px",
        marginLeft: "8px",
        cursor: "pointer",
        verticalAlign: "middle",
      });

      btn.addEventListener("click", async (e) => {
        e.stopPropagation();

        // This is safe because when you CLICK, the parent will always exist
        const parentTaskBox = span.parentElement;
        if (parentTaskBox) {
          parentTaskBox.classList.toggle("completed");
          const isCompleted = parentTaskBox.classList.contains("completed");

          // Save the updated status to the database
          const taskDate = new Date(task.date);
          const taskText = span.textContent.trim();
          const taskId = task._id;

          const success = await updateTaskStatus(taskId, isCompleted);
          if (!success) {
            alert("Failed to update task. Please try again.");
            // Toggle the class back to its original state
            parentTaskBox.classList.toggle("completed");
          }

          // await saveTask(parentTaskBox, taskText, task.color, taskDate, taskId, success ? isCompleted : !isCompleted);
        }
      });
      return btn;
    }


    function balanceColumnHeights() {
      const allDayBoxes = [...document.querySelectorAll(".day-box")];
      if (allDayBoxes.length < 7) {
        return;
      }

      const mainBoxes = allDayBoxes.slice(0, 5); // Mon-Fri
      const saturdayBox = allDayBoxes[5];
      const sundayBox = allDayBoxes[6];

      if (mainBoxes.length < 5 || !saturdayBox || !sundayBox) {
        return;
      }

      // --- Part 1: Determine the true target height for the entire layout ---
      let maxRows = 0;
      const columnsToFindMax = [...mainBoxes, sundayBox];
      columnsToFindMax.forEach(box => {
        const todoList = box.querySelector('.todo-list');
        if (todoList && todoList.children.length > maxRows) {
          maxRows = todoList.children.length;
        }
      });

      const tempBox = mainBoxes[0].cloneNode(true);
      tempBox.style.visibility = 'hidden';
      document.body.appendChild(tempBox);
      const tempBoxList = tempBox.querySelector('.todo-list');
      while (tempBoxList.children.length < maxRows) {
        const emptyTaskBox = document.createElement("li");
        emptyTaskBox.style.height = "40px";
        tempBoxList.appendChild(emptyTaskBox);
      }
      const weekdayTargetHeight = tempBox.offsetHeight;
      document.body.removeChild(tempBox);

      const weekendTargetHeight = saturdayBox.offsetHeight + sundayBox.offsetHeight + 40; // 40 is the gap.
      const targetHeight = Math.max(weekdayTargetHeight, weekendTargetHeight);

      // --- Part 2: Adjust all columns to match the final target height ---
      mainBoxes.forEach(box => {
        const todoList = box.querySelector('.todo-list');
        const header = box.querySelector('div:first-child');
        if (!todoList || !header) return;

        const requiredListHeight = targetHeight - header.offsetHeight;
        const requiredRows = Math.floor(requiredListHeight / 40);

        while (todoList.children.length < requiredRows) {
          const emptyTaskBox = document.createElement("li");
          emptyTaskBox.style.height = "40px";
          emptyTaskBox.style.borderBottom = "1px solid #e0e0e0";
          todoList.appendChild(emptyTaskBox);
        }
      });

      const sundayTodoList = sundayBox.querySelector('.todo-list');
      const sundayHeader = sundayBox.querySelector('div:first-child');
      if (!sundayTodoList || !sundayHeader) return;

      const availableHeightForSundayList = targetHeight - saturdayBox.offsetHeight - 40 - sundayHeader.offsetHeight;
      const requiredSundayRows = Math.max(0, Math.floor(availableHeightForSundayList / 40));

      while (sundayTodoList.children.length < requiredSundayRows) {
        const emptyTaskBox = document.createElement("li");
        emptyTaskBox.style.height = "40px";
        emptyTaskBox.style.borderBottom = "1px solid #e0e0e0";
        sundayTodoList.appendChild(emptyTaskBox);
      }
      while (sundayTodoList.children.length > requiredSundayRows) {
        if (!sundayTodoList.lastChild.textContent.trim() && !sundayTodoList.lastChild.querySelector('input')) {
          sundayTodoList.removeChild(sundayTodoList.lastChild);
        } else {
          break;
        }
      }
    }

    async function updateTaskStatus(taskId, isCompleted) {
      try {
        const response = await fetch(`https://tweek-web-app-2.onrender.com/api/tasks/${taskId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem("token")}`
          },
          credentials: 'include',
          // Only send the field that is changing
          body: JSON.stringify({ completed: isCompleted })
        });

        if (!response.ok) {
          // If the server fails, log the error and return false
          console.error('Failed to update task status on the server.');
          return false;
        }

        console.log(`Task ${taskId} status updated to: ${isCompleted}`);
        return true; // Return true on success

      } catch (error) {
        console.error('Network error while updating task status:', error);
        return false; // Return false on network failure
      }
    }

    // use this for loadTasksFromDB
    function renderTaskElement(box, task) {
      box.innerHTML = "";
      box.dataset.id = task._id || "";

      const span = document.createElement("span");
      span.className = "task-text";
      span.textContent = task.title || task.text || ""; // FIX ✅
      styleTaskSpan(span, task.color || null);

      const checkBtn = createCheckBtn(span, task);

      box.append(span, checkBtn);
      if (task.completed) {
        box.classList.add("completed");
      }

      if (task && task._id) {
        box.draggable = true;

        box.addEventListener('dragstart', (e) => {
          // Store the task's ID to identify it on drop
          e.dataTransfer.setData('text/plain', task._id);
          // Add a class for visual styling while dragging
          setTimeout(() => box.classList.add('dragging'), 0);
        });

        box.addEventListener('dragend', () => {
          // Clean up the styling after the drag operation ends
          box.classList.remove('dragging');
        });
      }

      box.addEventListener("click", (e) => {
        e.stopPropagation();
        openEditModal(
          task.title,
          (newText, newColor, newNotes, newDate) => {
            handleTaskSave(box, newText, newColor, newNotes, newDate);
          },
          box,
          task.color,
          new Date(task.date)
        );
      });

      Object.assign(box.style, {
        height: "40px",
        display: "flex",
        borderBottom: "1px solid #e0e0e0",
        justifyContent: "space-between",
        alignItems: "center",
        fontWeight: "400"
      });

      box.title = task.title || task.text || ""; // FIX ✅
    }

    async function saveTask(box, text, color = null, taskDate, taskId = null, isCompleted = false, isSomeday = false) {
      // Basic validation to prevent saving empty tasks
      if (!text || text.trim() === "") {
        return;
      }

      // Prepare the data payload to send to the server
      const payload = {
        title: text.trim(),
        description: "",
        color,
        completed: isCompleted,
        isSomeday,
        date: isSomeday ? null : taskDate.toISOString()
      };

      // Determine if we are creating a new task (POST) or updating an existing one (PUT)
      const url = taskId
        ? `https://tweek-web-app-2.onrender.com/api/tasks/${taskId}`
        : "https://tweek-web-app-2.onrender.com/api/tasks";

      const method = taskId ? "PUT" : "POST";

      try {
        const res = await fetch(url, {
          method: method,
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${localStorage.getItem("token")}`
          },
          credentials: "include",
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          console.error(`Failed to ${method} task:`, await res.text());
          alert("Could not save the task. Please try again.");
          return;
        }

        // =========================================================================
        // THE FIX: Do not update the screen here. Instead, trigger a full refresh.
        // This ensures the UI is always perfectly in sync with the database,
        // preventing all duplication and race condition bugs.
        // =========================================================================
        await renderWeeklyView(currentViewDate);

      } catch (error) {
        console.error("Network error while saving task:", error);
        alert("A network error occurred. Please check your connection.");
      }
    }

    function activateInput(box, taskDate) {
      const input = createInput();
      box.textContent = "";
      box.appendChild(input);
      input.focus();

      const save = () => {
        if (input.value.trim()) {
          if (taskDate) {
            saveTask(box, input.value.trim(), null, taskDate);
          } else {
            saveTask(box, input.value.trim(), null, null, null, false, true);
          }
        } else {
          box.textContent = "";
        }
      };

      input.addEventListener("blur", () => setTimeout(save, 0));

      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          save();

          const currentBox = input.parentElement;
          const container = currentBox.parentElement;

          if (!container) return;

          const siblings = Array.from(container.children);
          const currentIndex = siblings.indexOf(currentBox);

          let nextBox = null;
          let newRowWasAdded = null;

          for (let i = currentIndex + 1; i < siblings.length; i++) {
            if (!siblings[i].textContent.trim() && !siblings[i].querySelector('input')) {
              nextBox = siblings[i];
              break;
            }
          }

          if (!nextBox) {
            const newBox = document.createElement(currentBox.tagName);
            newBox.style.height = "40px";
            if (currentBox.tagName.toLowerCase() === 'li') {
              newBox.style.borderBottom = "1px solid #e0e0e0";
            }
            container.appendChild(newBox);
            nextBox = newBox;

            newRowWasAdded = true;

          }
          if (nextBox) {
            activateInput(nextBox, taskDate);
          }

          if (newRowWasAdded) {
            // if (offset === 5) {
            //   const totalRows = saturdayBox.querySelectorAll(".todo-list li").length;
            //   saturdayBox.style.maxHeight = `${totalRows * rowHeight}px`;

            //   allDayBoxes.forEach((otherBox, idx) => {
            //     if (idx !== 5 && idx !== 6) {
            //       const otherTodoContainer = otherBox.querySelector(".todo-list");
            //       const newBox = document.createElement("li");
            //       newBox.style.height = `${rowHeight}`;
            //       otherTodoContainer.appendChild(newBox);
            //     }
            //   });
            // } else {
            //   const totalRows = saturdayBox.querySelectorAll(".todo-list li").length;
            //   saturdayBox.style.maxHeight = `${totalRows * rowHeight}px`;

            //   allDayBoxes.forEach((otherBox, idx) => {
            //     if (idx !== offset && idx !== 5) {
            //       const otherTodoContainer = otherBox.querySelector(".todo-list");
            //       const newBox = document.createElement("li");
            //       newBox.style.height = `${rowHeight}px`;
            //       otherTodoContainer.appendChild(newBox);
            //     }
            //   });
            // }
            balanceRows();
          }

        }
      });
    }


    // --- Weekly Days ---
    for (let offset = 0; offset < 7; offset++) {
      const date = new Date(monday);
      date.setDate(monday.getDate() + offset);
      const dateString = date.toISOString().split('T')[0];
      const tasksForThisDay = tasksByDate.get(dateString) || [];

      const dayBox = document.createElement("div");
      dayBox.className = "day-box";

      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-indexed
      const day = String(date.getDate()).padStart(2, '0');
      const dateStringForColumn = `${year}-${month}-${day}`;

      dayBox.dataset.dateColumn = dateStringForColumn;

      addDropZoneListeners(dayBox);

      Object.assign(dayBox.style, {
        padding: "0 10px",
        borderRadius: "8px",
        display: "flex",
        flexDirection: "column",
        minWidth: "150px",
        flexGrow: "1",
        cursor: "pointer",
      });

      const headerDiv = document.createElement("div");
      Object.assign(headerDiv.style, {
        display: "flex",
        justifyContent: "space-between",
        borderBottom: "2px solid black",
        paddingBottom: "7px",
      });
      const todoContainer = document.createElement("ul");
      applyHeaderStyle();

      function applyHeaderStyle() {
        if (window.innerWidth < 1024) {
          Object.assign(headerDiv.style, {
            width: "100%"
          });
          Object.assign(todoContainer.style, {
            width: "100%"
          })
        } else {
          Object.assign(headerDiv.style, {
            width: "105%"
          });
          Object.assign(todoContainer.style, {
            width: "105%"
          })
        }
      }

      const dayNumber = date.getDate().toString().padStart(2, "0");
      const monthNumber = (date.getMonth() + 1).toString().padStart(2, "0");

      const dateDiv = document.createElement("div");
      dateDiv.style.fontWeight = "bold";
      dateDiv.textContent = `${dayNumber}.${monthNumber}`;

      const weekdayDiv = document.createElement("div");
      weekdayDiv.textContent = weekdays[offset];
      weekdayDiv.style.color = "#000";
      weekdayDiv.style.textTransform = "capitalize";
      weekdayDiv.style.opacity = ".2";
      weekdayDiv.style.fontFamily = primaryFont;
      weekdayDiv.style.fontWeight = "400";

      headerDiv.append(dateDiv, weekdayDiv);

      // const todoContainer = document.createElement("ul");
      todoContainer.className = "todo-list";
      Object.assign(todoContainer.style, {
        margin: "0",
        paddingLeft: "1px",
        flexGrow: "1",
        listStyle: "none",
        fontSize: "16px",
      });

      // --- Dynamic row limits ---
      const minWeekdayRows = 12;
      const minWeekendRows = 5;


      // Count how many tasks we already have (if loaded from DB)
      const taskCount = tasksForThisDay.length;

      // Decide how many rows to render initially
      const minLimit = offset < 5 ? minWeekdayRows : minWeekendRows;
      const limit = Math.max(minLimit, taskCount);  // ensure at least min

      for (let i = 0; i < limit; i++) {
        const taskBox = document.createElement("li");
        taskBox.style.height = "40px";
        todoContainer.appendChild(taskBox);
      }

      // 2. NEW: Get a reference to all the rows you just created
      const allTaskBoxes = todoContainer.querySelectorAll('li');

      // 3. NEW: Loop through your fetched tasks and render each one into a row
      tasksForThisDay.forEach((task, index) => {
        // Make sure there is a box to put the task in
        if (allTaskBoxes[index]) {
          renderTaskElement(allTaskBoxes[index], task);
        }
      });

      // highlight today / selected
      const isToday =
        date.getDate() === currentDate.getDate() &&
        date.getMonth() === currentDate.getMonth() &&
        date.getFullYear() === currentDate.getFullYear();

      const isSelected =
        highlightDate &&
        date.getDate() === highlightDate.getDate() &&
        date.getMonth() === highlightDate.getMonth() &&
        date.getFullYear() === highlightDate.getFullYear();

      if (isSelected) {
        dateDiv.style.color = "#5167f4";
        weekdayDiv.style.color = "#5167f4";
      } else if (isToday) {
        dateDiv.style.color = "#5167f4";
        weekdayDiv.style.color = "#5167f4";
      }

      dayBox.append(headerDiv, todoContainer);

      dayBox.addEventListener("click", () => {
        const emptyBox = [...todoContainer.children].find(
          (box) => !box.textContent.trim() && !box.querySelector("input")
        );

        let newRowWasAdded = false;

        if (emptyBox) {
          activateInput(emptyBox, date);
        } else {
          const newBox = document.createElement("li");
          newBox.style.height = "40px";
          todoContainer.appendChild(newBox);
          activateInput(newBox, date);
          newRowWasAdded = true;
        }

        // All day boxes
        const allDayBoxes = [...weekContainer.querySelectorAll(".day-box")];
        const saturdayBox = allDayBoxes[5];
        const rowHeight = 40;

        if (newRowWasAdded) {
          // if (offset === 5) {
          //   const totalRows = saturdayBox.querySelectorAll(".todo-list li").length;
          //   saturdayBox.style.maxHeight = `${totalRows * rowHeight}px`;

          //   allDayBoxes.forEach((otherBox, idx) => {
          //     if (idx !== 5 && idx !== 6) {
          //       const otherTodoContainer = otherBox.querySelector(".todo-list");
          //       const newBox = document.createElement("li");
          //       newBox.style.height = `${rowHeight}`;
          //       otherTodoContainer.appendChild(newBox);
          //     }
          //   });
          // } else {
          //   const totalRows = saturdayBox.querySelectorAll(".todo-list li").length;
          //   saturdayBox.style.maxHeight = `${totalRows * rowHeight}px`;

          //   allDayBoxes.forEach((otherBox, idx) => {
          //     if (idx !== offset && idx !== 5) {
          //       const otherTodoContainer = otherBox.querySelector(".todo-list");
          //       const newBox = document.createElement("li");
          //       newBox.style.height = `${rowHeight}px`;
          //       otherTodoContainer.appendChild(newBox);
          //     }
          //   });
          // }
          balanceRows();
        }
      });

      if (offset < 5) firstRow.appendChild(dayBox);
      else satSunColumn.appendChild(dayBox);
    }

    firstRow.appendChild(satSunColumn);
    weekContainer.appendChild(firstRow);

    // --- Someday Section ---
    const somedayDiv = document.createElement("div");
    Object.assign(somedayDiv.style, {
      marginTop: "40px",
      width: "100%",
      cursor: "pointer",
      height: "40px"
    });

    const label = document.createElement("strong");
    label.textContent = "Someday";
    label.style.fontFamily = primaryFont;
    label.style.fontWeight = "700";
    label.style.fontSize = "21px";
    somedayDiv.appendChild(label);

    taskContainer = document.createElement("div");
    taskContainer.className = "task-container";
    taskContainer.dataset.isSomeday = "true";
    addDropZoneListeners(taskContainer);

    Object.assign(taskContainer.style, {
      display: "flex",
      flexDirection: "column",
      gap: "10px",
      marginTop: "10px",
    });

    for (let i = 0; i < 5; i++) {
      const taskBox = document.createElement("div");
      Object.assign(taskBox.style, {
        height: "40px",
        borderBottom: "1px solid #e0e0e0",
      });
      taskContainer.appendChild(taskBox);
    }

    somedayDiv.appendChild(taskContainer);
    weekContainer.appendChild(somedayDiv);

    somedayDiv.addEventListener("click", () => {
      const emptyBox = [...taskContainer.children].find(
        (box) => !box.textContent.trim() && !box.querySelector("input")
      );

      const targetBox = emptyBox || (() => {
        const newBox = document.createElement("div");
        taskContainer.appendChild(newBox);
        return newBox;
      })();

      activateInput(targetBox, null);
    });


    async function loadTasksFromDB() {
      function getWeekNumber(d) {
        d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        return `${d.getUTCFullYear()}-W${String(weekNo).padStart(2, '0')}`;
      }

      try {
        if (isLoggedIn) {
          const currentWeekId = getWeekNumber(monday);
          const weeklyTasksUrl = `https://tweek-web-app-2.onrender.com/api/tasks/week/${currentWeekId}`;
          const somedayTasksUrl = `https://tweek-web-app-2.onrender.com/api/tasks/someday`;

          const [weeklyRes, somedayRes] = await Promise.all([
            fetch(weeklyTasksUrl, { credentials: 'include', headers: { "Authorization": `Bearer ${localStorage.getItem("token")}` } }),
            fetch(somedayTasksUrl, { credentials: 'include', headers: { "Authorization": `Bearer ${localStorage.getItem("token")}` } })
          ]);

          if (!weeklyRes.ok || !somedayRes.ok) {
            throw new Error("Failed to fetch tasks");
          }

          const weeklyDataByUser = await weeklyRes.json();
          const somedayTasks = await somedayRes.json();

          weeklyDataByUser.forEach(userProfile => {
            // =================================================================
            // CRITICAL FIX: This block removes duplicates from the server data.
            // =================================================================
            const uniqueTasks = new Map();
            userProfile.tasks.forEach(task => {
              // By using the task's unique _id as the key, the Map automatically
              // overwrites any duplicates, ensuring we only have one of each.
              uniqueTasks.set(task._id, task);
            });

            // Now, we loop over the CLEAN, DE-DUPLICATED list of tasks.
            Array.from(uniqueTasks.values())
              .sort((a, b) => new Date(a.date) - new Date(b.date))
              .forEach(task => {
                const taskDate = new Date(task.date);

                const year = taskDate.getFullYear();
                const month = String(taskDate.getMonth() + 1).padStart(2, '0');
                const day = String(taskDate.getDate()).padStart(2, '0');
                const dateString = `${year}-${month}-${day}`;

                const dayColumn = document.querySelector(`.day-box[data-date-column="${dateString}"]`);

                if (dayColumn) {
                  const todoList = dayColumn.querySelector(".todo-list");
                  // Find the first empty row that doesn't already have a task ID
                  let box = [...todoList.children].find(li => !li.hasAttribute('data-id'));

                  // If no empty rows exist, create a new one
                  if (!box) {
                    box = document.createElement("li");
                    box.style.height = "40px";
                    box.style.borderBottom = "1px solid #e0e0e0";
                    todoList.appendChild(box);
                  }
                  // Render the single, unique task into the row
                  renderTaskElement(box, task);
                }
              });
          });

          // --- Render Someday Tasks ---
          const taskContainer = document.querySelector('[data-is-someday="true"]');
          if (taskContainer) { // Safety check
            somedayTasks.forEach(task => {
              let box = [...taskContainer.children].find(div => !div.hasAttribute('data-id'));
              if (box) {
                renderTaskElement(box, task);
              }
            });
          }
        }
      } catch (err) {
        console.error("Error loading tasks:", err);
      }
    }

    await loadTasksFromDB();

    balanceColumnHeights();
  } finally {
    isRendering = false;
  }
}


document.addEventListener('DOMContentLoaded', () => {
  renderWeeklyView();
})

document.getElementById("openCalendarBtn").addEventListener("click", () => {
  currentWeekDate = new Date();
  renderWeeklyView(new Date());
});


let prevweek = document.getElementById("prevweek");
let nextweek = document.getElementById("nextweek");

let currentWeekDate = new Date();
prevweek.addEventListener("click", () => {
  currentWeekDate.setDate(currentWeekDate.getDate() - 7);
  renderWeeklyView(currentWeekDate);
});

nextweek.addEventListener("click", () => {
  currentWeekDate.setDate(currentWeekDate.getDate() + 7);
  renderWeeklyView(currentWeekDate);
});

const taskTitleInput = document.querySelector('.modal-date');

const calendarDateText = document.querySelector('.calendar-date-text');
const modalDate = document.querySelector('.modal-date');

if (calendarDateText) {
  calendarDateText.textContent = formatDate(new Date());
}

flatpickr(modalDate, {
  defaultDate: new Date(),
  dateFormat: "D, d M Y",
  onChange: function (selectedDates) {
    if (calendarDateText && selectedDates[0]) {
      calendarDateText.textContent = formatDate(selectedDates[0]);
    }
  }
});

function setModalDate(date) {
  if (calendarDateText) {
    calendarDateText.textContent = formatDate(date);
  }
  if (modalDate._flatpickr) {
    modalDate._flatpickr.setDate(date, true);
  }
}

document.addEventListener('click', function (e) {
  const modalDateDiv = e.target.closest('.modal-date');
  if (modalDateDiv) {
    const dateValue = modalDateDiv.getAttribute('data-date');
    if (dateValue) {
      const dateObj = new Date(dateValue);
      taskTitleInput.value = formatDate(dateObj);
      if (taskTitleInput._flatpickr) {
        taskTitleInput._flatpickr.setDate(dateObj, true);
      }
    }
  }
});


//modal code
const editModal = document.getElementById("editModal");
const modalOverlay = document.getElementById("modalOverlay");
const modalTextarea = document.getElementById("taskTitle");
const taskNotes = document.getElementById("taskNotes");
const modalDateContainer = document.querySelector('.modal-date');
const deleteBtn = document.querySelector('#editModal .modal-actions button[title="Delete"]');
const colorButton = document.querySelector('button[title="Select Color"]');
const colorPicker = document.getElementById('colorPicker');
const taskCircle = document.getElementById('taskCircle');

// --- STATE VARIABLES ---
let currentEditableBox = null;
let selectedTaskColor = null;
let flatpickrInstance = null;
let onSaveCallback = null;
let currentTaskDate = null;

// --- DATE & CALENDAR LOGIC (FLATPICKR) ---
function formatDate(date) {
  if (!(date instanceof Date) || isNaN(date)) return "";
  const weekday = date.toLocaleDateString('en-US', { weekday: 'short' });
  const day = date.getDate();
  const month = date.toLocaleDateString('en-US', { month: 'short' });
  const year = date.getFullYear();
  return `${weekday}, ${day} ${month} ${year}`;
}

function autoResizeTextarea(element) {
  element.style.height = 'auto';
  element.style.height = element.scrollHeight + 'px';
}

if (taskNotes) {
  taskNotes.addEventListener('input', function () {
    autoResizeTextarea(this);
  });
}

// Initialize Flatpickr on the date container in the header
if (modalDateContainer) {
  flatpickrInstance = flatpickr(modalDateContainer, {
    dateFormat: "Y-m-d",
    onChange: function (selectedDates) {
      if (calendarDateText && selectedDates[0]) {
        currentTaskDate = selectedDates[0];
        calendarDateText.textContent = formatDate(currentTaskDate);
      }
    }
  });
}

function setModalDate(date) {
  if (!(date instanceof Date) || isNaN(date)) return;

  currentTaskDate = date;

  if (calendarDateText) {
    calendarDateText.textContent = formatDate(date);
  }

  if (flatpickrInstance) {
    flatpickrInstance.setDate(date, false); // false = don’t trigger onChange again
  }
}


// --- MODAL CORE FUNCTIONS ---
const openEditModal = function (
  oldText,
  callback,
  editableBox = null,
  currentColor = null,
  taskDate = new Date()
) {
  // Store state
  currentEditableBox = editableBox;
  selectedTaskColor = currentColor;
  onSaveCallback = callback;

  // Prefill modal fields
  modalTextarea.value = oldText || "";
  taskNotes.value = currentEditableBox?.dataset.notes || ""; // keep notes if stored in dataset
  autoResizeTextarea(taskNotes);
  setModalDate(taskDate);

  // Handle color
  colorPicker.value = selectedTaskColor;
  if (taskCircle) {
    taskCircle.style.backgroundColor =
      currentColor ? selectedTaskColor : "transparent";
  }

  // Show modal
  modalOverlay.style.display = "block";
  editModal.style.display = "block";
  setTimeout(() => editModal.classList.add("show"), 10);

  // Focus textarea
  modalTextarea.focus();

  // Ensure only one overlay listener is active
  modalOverlay.removeEventListener("click", handleOverlayClick);
  modalOverlay.addEventListener("click", handleOverlayClick);
};

// Replace your entire handleTaskSave function with this version

async function handleTaskSave(box, newText, color, notes, newDate) {
  if (!box) return;

  const taskId = box.dataset.id;
  if (!taskId) return;

  // --- Get Original Task Details ---
  const parentDayBox = box.closest('.day-box, .someday-task-container');
  const oldIsSomeday = !box.closest('.day-box');
  const oldDate = oldIsSomeday ? null : new Date(box.closest('.day-box').dataset.dateColumn);
  const getWeekNumber = (d) => { // This can be moved to a higher scope if you prefer
    if (!d) return null;
    d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return `${d.getUTCFullYear()}-W${String(weekNo).padStart(2, '0')}`;
  };
  const oldWeekId = getWeekNumber(oldDate);
  const isCompleted = box.classList.contains('completed');
  const newIsSomeday = !newDate;

  // --- 1. Send Update to Server ---
  try {
    const response = await fetch(`${API_BASE_URL}api/tasks/${taskId}`, {
      method: "PUT",
      headers: {
        "Authorization": `Bearer ${localStorage.getItem("token")}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        title: newText,
        date: newDate ? newDate.toISOString() : null,
        completed: isCompleted,
        color: color
      }),
      credentials: "include"
    });

    if (!response.ok) {
      throw new Error(`Server update failed: ${await response.text()}`);
    }

    const updatedTask = await response.json();

    // --- 2. Update the UI intelligently ---
    const textSpan = box.querySelector('.task-text');
    if (textSpan) textSpan.textContent = newText;
    box.dataset.notes = notes;

    // Directly compare the year, month, and day to avoid timezone issues.
    const datesAreTheSame = oldDate && newDate &&
      (oldDate.getFullYear() === newDate.getFullYear()) &&
      (oldDate.getMonth() === newDate.getMonth()) &&
      (oldDate.getDate() === newDate.getDate());

    if ((oldIsSomeday && newIsSomeday) || datesAreTheSame) {
      console.log("Task updated in place. No move needed.");

      // Update dataset + UI directly
      box.dataset.color = color;
      const textSpan = box.querySelector(".task-text");
      if (textSpan) {
        textSpan.textContent = newText;
        textSpan.style.backgroundColor = color;
      }
      return; // ✅ no re-render
    }



    // Condition 2: The date HAS changed. We need to move the element.
    console.log("Task date changed. Moving element...");
    // renderWeeklyView(currentDate); // The easiest way to reflect the move is to re-render the view

  } catch (error) {
    console.error("Failed to save task:", error);
  }
}

function closeEditModal() {
  editModal.classList.remove("show");
  modalOverlay.removeEventListener("click", handleOverlayClick);
  setTimeout(() => {
    modalOverlay.style.display = "none";
    editModal.style.display = "none";
  }, 300);
}

function saveAndClose() {
  if (typeof onSaveCallback === 'function') {
    const newText = modalTextarea.value;
    const notes = taskNotes.value;
    const color = selectedTaskColor;
    onSaveCallback(newText, color, notes, currentTaskDate);
  }
  closeEditModal();
}

function handleOverlayClick(e) {
  if (e.target === modalOverlay) {
    saveAndClose();
  }
}

// delte button logic
if (deleteBtn) {
  deleteBtn.addEventListener('click', async () => {
    if (!currentEditableBox) {
      return;
    }
    const taskId = currentEditableBox.dataset.id;

    if (!taskId) {
      console.error("Delete failed: No task ID found on the element.");
      closeEditModal();
      return;
    }

    try {
      const response = await fetch(`https://tweek-web-app-2.onrender.com/api/tasks/${taskId}`, {
        method: "DELETE",
        headers: {
          "Authorization": `Bearer ${localStorage.getItem("token")}`,
        },
        credentials: "include"
      });

      if (response.ok) {
        console.log("Task deleted successfully on server.");
        currentEditableBox.remove();
      } else {
        const errorData = await response.json();
        console.error("Failed to delete task:", errorData.error);
        alert(`Error: ${errorData.error}`);
      }

    } catch (error) {
      console.error("A network error occurred:", error);
      alert("Could not connect to the server to delete the task.");
    } finally {
      closeEditModal();
    }
  });
}

// Initialize the custom color picker when the page loads
Coloris({
  el: '#colorPicker',
  theme: 'default',
  themeMode: 'dark',
  alpha: false,
  format: 'hex'
});

if (colorButton) {
  colorButton.addEventListener('click', () => colorPicker.click());
}

document.addEventListener('coloris:pick', event => {
  selectedTaskColor = event.detail.color;
  if (taskCircle) {
    taskCircle.style.backgroundColor = selectedTaskColor;
  }
  if (currentEditableBox) {
    const textSpan = currentEditableBox.querySelector('.task-text');
    if (textSpan) {
      textSpan.style.backgroundColor = selectedTaskColor;
    }
  }
});

//share calendar code
document.addEventListener('DOMContentLoaded', () => {
  // Modal elements
  const shareModal = document.getElementById('shareModal'); // Your modal container
  const shareModalOverlay = document.getElementById('shareModalOverlay');
  const closeShareModalBtn = document.getElementById('closeShareModalBtn');
  const shareEmailInput = document.getElementById('shareEmailInput');
  const shareBtn = document.getElementById('shareBtn');
  const sharedWithList = document.getElementById('sharedWithList');
  const shareTaskBtn = document.getElementById('share-task-btn'); // The main button to open the modal

  // --- FUNCTIONS ---

  // Opens the modal and populates it with data for the CURRENTLY selected calendar
  async function openShareModal() {
    const calendarId = window.getSelectedCalendarId(); 
    if (!calendarId) {
      alert("Please select a calendar first.");
      return;
    }

    try {
      const res = await fetch(`${API_BASE_URL}/api/calendars/${calendarId}/shared-with`, {
        headers: { 'Authorization': `Bearer ${localStorage.getItem("token")}` },
        credentials: "include",
      });
      if (res.status === 403) {
        alert("You can only share calendars that you own.");
        return;
      }
      if (!res.ok) throw new Error('Could not fetch shared list');

      const users = await res.json();
      renderSharedWithList(users);

      // Show the modal
      shareModal.style.display = 'block';
      shareModalOverlay.style.display = 'block';

    } catch (error) {
      console.error(error);
      alert('Could not open sharing options.');
    }
  }

  function closeShareModal() {
    shareModal.style.display = 'none';
    shareModalOverlay.style.display = 'none';
    shareEmailInput.value = '';
  }

  function renderSharedWithList(users) {
    sharedWithList.innerHTML = '';
    if (users.length === 0) {
      sharedWithList.innerHTML = '<li>Not shared with anyone yet.</li>';
      return;
    }
    users.forEach(user => {
      const li = document.createElement('li');
      li.innerHTML = `
                <span>${user.email}</span>
                <button class="unshare-btn" data-email="${user.email}">Unshare</button>
            `;
      sharedWithList.appendChild(li);
    });
  }

  // --- EVENT LISTENERS ---

  if (shareTaskBtn) {
    shareTaskBtn.addEventListener('click', openShareModal);
  }
  closeShareModalBtn.addEventListener('click', closeShareModal);
  shareModalOverlay.addEventListener('click', closeShareModal);

  // Share button inside modal
  shareBtn.addEventListener('click', async () => {
    const calendarId = window.getSelectedCalendarId();
    const email = shareEmailInput.value.trim();
    if (!email) return alert('Please enter an email address.');

    try {
      const res = await fetch(`${API_BASE_URL}/api/calendars/${calendarId}/share`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem("token")}`
        },
        body: JSON.stringify({ shareWithEmail: email }),
        credentials: 'include'
      });

      const result = await res.json();
      if (!res.ok) throw new Error(result.error || 'Failed to share.');

      alert(result.message);
      shareEmailInput.value = '';
      await openShareModal(); // Refresh the list

    } catch (error) {
      alert(`Error: ${error.message}`);
    }
  });

  // Unshare button clicks (event delegation)
  sharedWithList.addEventListener('click', async (e) => {
    if (!e.target.classList.contains('unshare-btn')) return;

    const calendarId = window.getSelectedCalendarId();
    const email = e.target.dataset.email;
    if (!confirm(`Stop sharing this calendar with ${email}?`)) return;

    try {
      const res = await fetch(`${API_BASE_URL}/api/calendars/${calendarId}/unshare`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem("token")}`
        },
        body: JSON.stringify({ unshareWithEmail: email }),
        credentials: 'include'
      });

      const result = await res.json();
      if (!res.ok) throw new Error(result.error);

      alert(result.message);
      e.target.parentElement.remove(); // Remove from UI

    } catch (error) {
      alert(`Error: ${error.message}`);
    }
  });
});

// This script assumes you have a way to get the user's auth token
// For example, from localStorage after they log in.

// calnder share task
document.addEventListener('DOMContentLoaded', () => {
  // --- 1. STATE MANAGEMENT ---
  // We'll store all data fetched from the server here
  let allFetchedTasks = [];
  let allCalendars = [];
  let selectedCalendarIds = [];

  // --- 2. INITIALIZATION ---
  // This function runs when the page loads
  async function initializeApp() {
    // await checkLoginStatus();
    if (isLoggedIn) {
      console.log("User is logged in. Fetching data...");
      // Now it's safe to call these functions
      await fetchAndRenderCalendars();
      const currentWeekId = getCurrentWeekId();
      await fetchAndRenderTasks(currentWeekId);
    } else {
      console.log("User is a guest. Rendering guest view.");
      // If you have a function to render the view for logged-out users,
      // you would call it here. For example:
      renderWeeklyView(); // This will use guest tasks from localStorage
    }
    // Assuming you have a function to get the current week ID

  }

  // --- 3. FETCHING DATA FROM API ---

  // This function replaces your old fetchAndRenderCalendars
  async function fetchAndRenderCalendars() {
    try {
      // This endpoint is the new GET /api/calendars from the backend section
      const response = await fetch(`${API_BASE_URL}/api/calendars`, {
        headers: { 'Authorization': `Bearer ${getAuthToken()}` },
        credentials: 'include'
      });
      if (!response.ok) throw new Error('Failed to fetch calendars');

      allCalendars = await response.json(); // Contains both owned and shared calendars
      renderCalendarList();

    } catch (error) {
      console.error('Error fetching calendars:', error);
    }
  }

  function renderCalendarList() {
    const container = document.getElementById('calendar-list-container');
    container.innerHTML = '';
    selectedCalendarIds = []; // Reset selections

    allCalendars.forEach(calendar => {
      // The unique ID for filtering is now the calendar's own ID
      const calendarId = calendar._id;
      selectedCalendarIds.push(calendarId); // Select all by default
      console.log("Rendering calendar:", calendar.name, "ID:", calendarId);
      const calendarItem = document.createElement('label');
      calendarItem.className = 'calendar-item';
      calendarItem.setAttribute('for', `cal-checkbox-${calendarId}`);

      // Display the owner's name if it's a shared calendar
      const displayName = calendar.isOwnedByCurrentUser
        ? calendar.name
        : `${calendar.name} (${calendar.owner.firstName})`;

      calendarItem.innerHTML = `
            <input type="checkbox" id="cal-checkbox-${calendarId}" value="${calendarId}" checked>
            <span>${displayName}</span>
            `;
      container.appendChild(calendarItem);

      calendarItem.querySelector('input').addEventListener('change', (event) => {
        handleCalendarSelection(event.target.value, event.target.checked);
      });
    });

    renderVisibleTasks(); // Initial render with all calendars selected
  }

  // Fetches all tasks for a given week from all accessible calendars
  async function fetchAndRenderTasks(weekId) {
    try {
      const response = await fetch(`${API_BASE_URL}/api/tasks/week/${weekId}`, {
        headers: {
          'Authorization': `Bearer ${getAuthToken()}`
        },
        credentials: 'include'
      });
      if (!response.ok) throw new Error('Failed to fetch tasks');

      allFetchedTasks = profilesWithTasks.flatMap(profile => {
        // For each profile, take its 'tasks' array...
        return profile.tasks.map(task => ({
          ...task, // Keep all original task properties (title, date, etc.)
          userId: profile.userId // And add the owner's userId to it
        }));
      });

      console.log("Processed flat task list:", allFetchedTasks);
      renderVisibleTasks(); // Render the tasks based on selected calendars

    } catch (error) {
      console.error(`Error fetching tasks for ${weekId}:`, error);
    }
  }

  // This function is updated
  async function fetchAndRenderTasks(weekId) {
    try {
      // This single call gets ALL visible tasks (yours and shared) for the week
      const response = await fetch(`${API_BASE_URL}/api/tasks/week/${weekId}`, {
        headers: { 'Authorization': `Bearer ${getAuthToken()}` }
      });
      if (!response.ok) throw new Error('Failed to fetch tasks');

      // The response is now a flat array, no processing needed
      allFetchedTasks = await response.json();

      console.log("Fetched all visible tasks:", allFetchedTasks);
      renderVisibleTasks(); // Render based on currently selected calendars

    } catch (error) {
      console.error(`Error fetching tasks for ${weekId}:`, error);
    }
  }

  // Update the filtering logic to use task.calendar
  function renderVisibleTasks() {
    const tasksToDisplay = allFetchedTasks.filter(task =>
      // The task object has a 'calendar' field with the Calendar's ID
      selectedCalendarIds.includes(task.calendar)
    );

    // This is your function that draws the tasks on the screen
    displayTasksOnGrid(tasksToDisplay);
  }

  // handleCalendarSelection remains the same, as it already works with the selectedCalendarIds array
  function handleCalendarSelection(calendarId, isSelected) {
    if (isSelected) {
      if (!selectedCalendarIds.includes(calendarId)) {
        selectedCalendarIds.push(calendarId);
      }
    } else {
      selectedCalendarIds = selectedCalendarIds.filter(id => id !== calendarId);
    }
    renderVisibleTasks();
  }

  
  // --- 4. RENDERING LOGIC ---

  // // Builds the HTML for the calendar list in the dropdown
  // function renderCalendarList() {
  //   const container = document.getElementById('calendar-list-container');
  //   if (!container) return;

  //   container.innerHTML = ''; // Clear previous list
  //   selectedCalendarIds = []; // Reset selections

  //   allCalendars.forEach(calendar => {
  //     // This is the unique ID for the calendar's owner, used for filtering.
  //     // It's guaranteed to exist for both personal and shared calendars.
  //     const calendarOwnerId = calendar.owner._id;
  //     const calendarUniqueId = calendar._id;
  //     selectedCalendarIds.push(calendarOwnerId); // Select all by default

  //     const calendarItem = document.createElement('label');
  //     calendarItem.className = 'calendar-item';
  //     // The 'for' attribute of a label should match the 'id' of an input
  //     calendarItem.setAttribute('for', `cal-checkbox-${calendarUniqueId}`);

  //     // Add an icon for the user's personal calendar
  //     const iconHtml = calendar.isPersonal
  //       ? `<svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>`
  //       : '';

  //     calendarItem.innerHTML = `
  //           <input type="checkbox" id="cal-checkbox-${calendarUniqueId}" value="${calendarOwnerId}" checked>
  //           ${iconHtml}
  //           <span>${calendar.name}</span>
  //       `;

  //     container.appendChild(calendarItem);

  //     // Add event listener to the checkbox
  //     calendarItem.querySelector('input[type="checkbox"]').addEventListener('change', (event) => {
  //       handleCalendarSelection(event.target.value, event.target.checked);
  //     });
  //   });
  // }

  // // Renders only the tasks that belong to the currently selected calendars
  // function renderVisibleTasks() {
  //   // Filter the master list of tasks
  //   const tasksToDisplay = allFetchedTasks.filter(task =>
  //     selectedCalendarIds.includes(task.userId) // The backend uses userId to identify the owner
  //   );

  //   // Now, call your existing function to render tasks on the screen
  //   // IMPORTANT: You need to replace 'displayTasksOnGrid' with the name of YOUR function
  //   // that actually puts the tasks into the HTML.
  //   displayTasksOnGrid(tasksToDisplay);
  // }

  // // --- 5. EVENT HANDLERS ---

  // // Updates the list of selected calendars and re-renders the tasks
  // function handleCalendarSelection(calendarId, isSelected) {
  //   if (isSelected) {
  //     if (!selectedCalendarIds.includes(calendarId)) {
  //       selectedCalendarIds.push(calendarId);
  //     }
  //   } else {
  //     selectedCalendarIds = selectedCalendarIds.filter(id => id !== calendarId);
  //   }

  //   // Re-render the visible tasks without fetching from the server again
  //   renderVisibleTasks();
  // }


  // --- 6. HELPER FUNCTIONS (You need to provide these) ---

  function getAuthToken() {
    // Replace this with your actual logic to get the token
    return localStorage.getItem('authToken');
  }

  function getCurrentWeekId() {
    // Replace this with your existing logic to calculate the current week string (e.g., "2025-W38")
    // This is just a placeholder example:
    const d = new Date();
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return `${d.getUTCFullYear()}-W${String(weekNo).padStart(2, '0')}`;
  }

  function displayTasksOnGrid(tasks) {
    // **VERY IMPORTANT**: This is where you put YOUR code that takes an array
    // of task objects and displays them on your calendar grid.
    // For example:
    console.log("Rendering these tasks:", tasks);
    const taskGrid = document.getElementById('task-grid'); // Or whatever your container is
    taskGrid.innerHTML = ''; // Clear the grid
    // ... then loop through 'tasks' and create the HTML for each one.
  }

  // Start the application
  initializeApp();
});

//repeate modal
document.addEventListener('DOMContentLoaded', () => {
  // Get all necessary elements from the DOM
  const openModalBtn = document.getElementById('open-modal-btn');
  const modalOverlay = document.getElementById('repeat-modal');
  const closeModalBtn = document.getElementById('close-modal-btn');
  const modalOptions = modalOverlay.querySelectorAll('li');

  // --- Function to open the modal ---
  const openModal = () => {
    modalOverlay.classList.add('active');
    openModalBtn.classList.add('active'); // Highlight the trigger button
  };

  // --- Function to close the modal ---
  const closeModal = () => {
    modalOverlay.classList.remove('active');
    openModalBtn.classList.remove('active'); // Un-highlight the trigger button
  };

  // --- Event Listeners ---

  // 1. Open modal when the button is clicked
  openModalBtn.addEventListener('click', openModal);

  // 2. Close modal when the 'X' button is clicked
  closeModalBtn.addEventListener('click', closeModal);

  // 3. Close modal when clicking on the overlay (the dark background)
  modalOverlay.addEventListener('click', (event) => {
    // We only close if the click is on the overlay itself, not its children
    if (event.target === modalOverlay) {
      closeModal();
    }
  });

  // 4. Close modal when the "Escape" key is pressed
  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
      closeModal();
    }
  });

  // 5. Handle the selection of a new option
  modalOptions.forEach(option => {
    option.addEventListener('click', () => {
      // Remove 'selected' class from the previous selection
      modalOverlay.querySelector('.selected')?.classList.remove('selected');

      // Add 'selected' class to the newly clicked option
      option.classList.add('selected');

      const newSelection = option.dataset.value;
      console.log('Repeat option selected:', newSelection);

      // Close the modal after making a selection
      closeModal();
    });
  });
});

function insertAtCursor(textArea, openTag, closeTag = "") {
  const start = textArea.selectionStart;
  const end = textArea.selectionEnd;
  const selectedText = textArea.value.substring(start, end);

  const before = textArea.value.substring(0, start);
  const after = textArea.value.substring(end);

  const newText = before + openTag + selectedText + closeTag + after;

  textArea.value = newText;

  const cursorPos = start + openTag.length + selectedText.length + closeTag.length;
  textArea.selectionStart = textArea.selectionEnd = cursorPos;
  textArea.focus();
}

let currentFontSize = 15;
let headingApplied = false;


document.getElementById("btnheading").addEventListener("click", () => {
  if (!headingApplied) {
    currentFontSize += 2;
    taskNotes.style.fontSize = currentFontSize + "px";

    const value = taskNotes.value;
    const cursorPos = taskNotes.selectionStart;

    const newValue = value.slice(0, cursorPos) + "\n" + value.slice(cursorPos);
    taskNotes.value = newValue;

    taskNotes.selectionStart = taskNotes.selectionEnd = cursorPos + 2;
    taskNotes.focus();

    headingApplied = true;

    const onEnter = (e) => {
      if (e.key === "Enter") {
        setTimeout(() => {
          currentFontSize = 15;
          taskNotes.style.fontSize = currentFontSize + "px";
          headingApplied = false;
          taskNotes.removeEventListener("keydown", onEnter);
        }, 0);
      }
    };

    taskNotes.addEventListener("keydown", onEnter);
  }
});


document.getElementById("btnbold").addEventListener("click", () => {
  if (taskNotes) {
    taskNotes.style.fontWeight =
      taskNotes.style.fontWeight === "bold" ? "normal" : "bold";
  }
});

document.getElementById("btnlist").addEventListener("click", () => {
  const textarea = document.getElementById("taskNotes");
  const lines = textarea.value.split("\n");

  const newLines = lines.map(line => {
    const trimmed = line.trimStart();
    if (trimmed.startsWith("• ")) {
      return trimmed.replace(/^•\s/, "");
    } else {
      return "• " + trimmed;
    }
  });

  textarea.value = newLines.join("\n");
});

document.getElementById("btnstream").addEventListener("click", () => {
  insertAtCursor(taskNotes, "\n> ", "\n");
});

document.getElementById("link").addEventListener("click", () => {
  const url = prompt("Enter the URL");
  if (!url) return;

  const start = taskNotes.selectionStart;
  const end = taskNotes.selectionEnd;
  const selectedText = taskNotes.value.substring(start, end) || "link text";

  const before = taskNotes.value.substring(0, start);
  const after = taskNotes.value.substring(end);

  taskNotes.value = before + `[${selectedText}](${url})` + after;

  const cursorPos = before.length + `[${selectedText}](${url})`.length;
  taskNotes.selectionStart = taskNotes.selectionEnd = cursorPos;
  taskNotes.focus();
});

//more option 
document.addEventListener('DOMContentLoaded', () => {
  const moreOptionsBtn = document.getElementById('moreOptionsBtn');
  const modalOverlay = document.getElementById('more-options-modal');
  const optionsList = modalOverlay.querySelector('.options-list');
  const taskCard = document.querySelector('#editModal');

  // This simulates the data of the task you clicked on.
  const currentTask = {
    id: taskCard.dataset.taskId,
    title: taskCard.querySelector('span').textContent
  };

  // --- Functions ---
  const openModal = () => modalOverlay.classList.add('active');
  const closeModal = () => modalOverlay.classList.remove('active');

  // --- Event Listeners ---
  moreOptionsBtn.addEventListener('click', (event) => {
    event.stopPropagation(); // Prevents the window listener from closing it immediately
    openModal();
  });

  modalOverlay.addEventListener('click', (event) => {
    // Close if the click is on the overlay itself
    if (event.target === modalOverlay) {
      closeModal();
    }
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
      closeModal();
    }
  });

  // --- Main Logic for Handling Actions ---
  optionsList.addEventListener('click', (event) => {
    const clickedOption = event.target.closest('li');

    if (!clickedOption || clickedOption.classList.contains('disabled')) {
      return; // Do nothing if it's not a valid option or is disabled
    }

    const action = clickedOption.dataset.action;

    // In a real app, you would call your API here.
    // We will simulate the actions with console logs.
    console.log(`Action: '${action}' on Task ID: '${currentTask.id}'`);

    switch (action) {
      case 'tomorrow':
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        console.log(`Simulating: Set date to ${tomorrow.toDateString()}`);
        // Example API call: updateTask(currentTask.id, { date: tomorrow });
        break;

      case 'next-week':
        const nextWeek = new Date();
        nextWeek.setDate(nextWeek.getDate() + 7);
        console.log(`Simulating: Set date to ${nextWeek.toDateString()}`);
        // Example API call: updateTask(currentTask.id, { date: nextWeek });
        break;

      case 'someday':
        console.log("Simulating: Moving task to 'Someday' list.");
        // Example API call: updateTask(currentTask.id, { isSomeday: true });
        break;

      case 'duplicate':
        console.log(`Simulating: Duplicating task "${currentTask.title}".`);
        // Example API call: createTask({ title: `${currentTask.title} (Copy)` });
        break;

      case 'add-file':
        // This case won't be reached because of the 'disabled' check,
        // but if it were enabled, it would open a file dialog.
        console.log("Simulating: Opening file upload dialog.");
        break;
    }

    closeModal(); // Close the modal after performing an action
  });
});


//reminder option
document.addEventListener('DOMContentLoaded', () => {

  // --- Core Reminder Elements ---
  const remindBtn = document.getElementById('reminder-btn'); // Your main trigger button
  const reminderPopover = document.getElementById('reminder-popover'); // The popover for the reminder
  const setReminderBtn = document.getElementById('set-reminder-btn-popover');

  // Elements inside the popover
  const dateDisplay = document.getElementById('date-display-popover');
  const prevDayBtn = document.getElementById('prev-day-btn-popover');
  const nextDayBtn = document.getElementById('next-day-btn-popover');
  const hourValue = document.getElementById('hour-value-popover');
  const minuteValue = document.getElementById('minute-value-popover');
  const ampmValue = document.getElementById('ampm-value-popover');
  const timeArrows = reminderPopover.querySelectorAll('.arrow');

  // --- State Variable ---
  let selectedDate = new Date();

  // --- Helper Functions ---
  const formatDate = (date) => {
    return date.toLocaleDateString('en-US', {
      weekday: 'short', day: 'numeric', month: 'short'
    });
  };

  const updateDateDisplay = () => {
    dateDisplay.textContent = formatDate(selectedDate);
  };

  const updateTimeDisplay = (hour, minute, ampm) => {
    hourValue.textContent = String(hour).padStart(2, '0');
    minuteValue.textContent = String(minute).padStart(2, '0');
    ampmValue.textContent = ampm;
  };

  // --- Main Functions to Open/Close Popover ---

  // Positions and shows the popover
  const openReminderPopover = () => {
    const btnRect = remindBtn.getBoundingClientRect();
    reminderPopover.style.left = `300px`;
    reminderPopover.style.top = `90px`;
    reminderPopover.classList.add('active');
    remindBtn.classList.add('active');
  };

  // Hides the popover
  const closeReminderPopover = () => {
    reminderPopover.classList.remove('active');
    remindBtn.classList.remove('active');
  };

  // --- Event Listeners ---

  // 1. Open the popover when the reminder button is clicked
  remindBtn.addEventListener('click', (event) => {
    event.stopPropagation(); // Prevent click from bubbling up to the window

    // If it's already open, close it. Otherwise, open it.
    if (reminderPopover.classList.contains('active')) {
      closeReminderPopover();
    } else {
      // Initialize picker with current date and a sensible time
      selectedDate = new Date();
      let h = new Date().getHours();
      let m = new Date().getMinutes();
      let ampm = h >= 12 ? 'PM' : 'AM';
      h = h % 12;
      h = h ? h : 12; // Hour '0' should be '12'
      m = Math.round(m / 15) * 15; // Round to nearest 15 mins
      if (m === 60) { m = 0; h += 1; }

      updateDateDisplay();
      updateTimeDisplay(h, m, ampm);
      openReminderPopover();
    }
  });

  // 2. Handle date changes
  prevDayBtn.addEventListener('click', () => {
    selectedDate.setDate(selectedDate.getDate() - 1);
    updateDateDisplay();
  });

  nextDayBtn.addEventListener('click', () => {
    selectedDate.setDate(selectedDate.getDate() + 1);
    updateDateDisplay();
  });

  // 3. Handle time changes using event delegation on arrows
  timeArrows.forEach(arrow => {
    arrow.addEventListener('click', () => {
      let unit = arrow.dataset.unit;
      let change = parseInt(arrow.dataset.change);

      let h = parseInt(hourValue.textContent);
      let m = parseInt(minuteValue.textContent);
      let ampm = ampmValue.textContent;

      if (unit === 'hour') h = (h + change - 1 + 12) % 12 + 1;
      if (unit === 'minute') m = (m + change + 60) % 60;
      if (unit === 'ampm') ampm = ampm === 'AM' ? 'PM' : 'AM';

      updateTimeDisplay(h, m, ampm);
    });
  });

  // 4. Handle setting the reminder
  setReminderBtn.addEventListener('click', () => {
    const finalDate = dateDisplay.textContent;
    const finalTime = `${hourValue.textContent}:${minuteValue.textContent} ${ampmValue.textContent}`;

    console.log("--- Reminder Set ---");
    console.log("Reminder Date:", finalDate);
    console.log("Reminder Time:", finalTime);
    console.log("This data would now be sent to your server via an API call.");

    closeReminderPopover();
  });

  // 5. Close the popover if clicking anywhere else on the page
  window.addEventListener('click', (event) => {
    if (!reminderPopover.contains(event.target) && !remindBtn.contains(event.target)) {
      closeReminderPopover();
    }
  });
});

// async function checkLoginStatus() {
//   try {
//     const response = await fetch(`${API_BASE_URL}/profile`, { method: 'GET', credentials: 'include' });
//     if (!response.ok) throw new Error('Not authenticated');
//     const data = await response.json();
//     updateAuthState(true, data.user);
//   } catch (error) {
//     updateAuthState(false);
//   }
// }

// function updateAuthState(loggedIn, user = null) {
//   isLoggedIn = loggedIn;
//   if (sessionRefreshInterval) clearInterval(sessionRefreshInterval);

//   if (isLoggedIn && user) {
//     const firstName = user.firstName || 'User';
//     const lastName = user.lastName || '';
//     const initials = (firstName[0] + (lastName[0] || '')).toUpperCase();
//     authTrigger.innerHTML = initials;
//     authTrigger.classList.add('text');
//     dropdownInitials.textContent = initials;
//     dropdownFullname.textContent = `${firstName} ${lastName}`.trim();
//     authModalBackdrop.classList.add('hidden');
//     // Set up token refresh
//     sessionRefreshInterval = setInterval(() => fetch(`${API_BASE_URL}/auth/refresh-token`, { method: 'POST', credentials: 'include' }), 6 * 24 * 60 * 60 * 1000);
//   } else {
//     authTrigger.innerHTML = loginIconSVG;
//     authTrigger.classList.remove('text');
//     profileDropdown.classList.add('hidden');
//   }
// }

function initializeAuthSystem() {
  const API_BASE_URL = "https://tweek-web-app-2.onrender.com";

  // --- DOM ELEMENTS ---
  const authTrigger = document.getElementById('auth-trigger');
  const authModalBackdrop = document.getElementById('auth-modal-backdrop');
  const closeModalBtn = document.getElementById('close-modal-btn');
  const modalTitle = document.getElementById('modal-title');
  const messageArea = document.getElementById('messageArea');

  // Forms
  const loginForm = document.getElementById('loginForm');
  const registerForm = document.getElementById('registerForm');
  const verifyForm = document.getElementById('verifyForm');

  // Links to switch forms
  const showRegisterLink = document.getElementById('showRegisterLink');
  const showLoginLinkFromRegister = document.getElementById('showLoginLinkFromRegister');

  // Profile Display
  const profileDropdown = document.getElementById('profile-dropdown');
  const dropdownInitials = document.getElementById('dropdown-initials');
  const dropdownFullname = document.getElementById('dropdown-fullname');
  const logoutButton = document.getElementById('logout-button');

  // --- STATE ---
  let currentEmailForVerification = ''; // To store email between register and verify steps
  let sessionRefreshInterval = null;
  const loginIconSVG = `<svg xmlns="http://www.w.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>`;

  // --- HELPER FUNCTIONS ---
  function showMessage(message, isError = false) {
    messageArea.textContent = message;
    messageArea.className = isError ? 'message-error' : 'message-success';
    messageArea.style.display = message ? 'block' : 'none';
  }

  function showView(viewToShow) {
    // Hide all forms first
    loginForm.classList.add('hidden');
    registerForm.classList.add('hidden');
    verifyForm.classList.add('hidden');
    // Show the requested form
    viewToShow.classList.remove('hidden');
    // Update modal title
    if (viewToShow === loginForm) modalTitle.textContent = 'Login to Your Account';
    if (viewToShow === registerForm) modalTitle.textContent = 'Create an Account';
    if (viewToShow === verifyForm) modalTitle.textContent = 'Verify Your Email';
    showMessage(''); // Clear any previous messages
  }

  // --- MAIN AUTH LOGIC ---
  function updateAuthState(loggedIn, user = null) {
    isLoggedIn = loggedIn;
    if (sessionRefreshInterval) clearInterval(sessionRefreshInterval);

    if (isLoggedIn && user) {
      const firstName = user.firstName || 'User';
      const lastName = user.lastName || '';
      const initials = (firstName[0] + (lastName[0] || '')).toUpperCase();
      authTrigger.innerHTML = initials;
      authTrigger.classList.add('text');
      dropdownInitials.textContent = initials;
      dropdownFullname.textContent = `${firstName} ${lastName}`.trim();
      authModalBackdrop.classList.add('hidden');
      // Set up token refresh
      sessionRefreshInterval = setInterval(() => fetch(`${API_BASE_URL}/auth/refresh-token`, { method: 'POST', credentials: 'include' }), 6 * 24 * 60 * 60 * 1000);
    } else {
      authTrigger.innerHTML = loginIconSVG;
      authTrigger.classList.remove('text');
      profileDropdown.classList.add('hidden');
    }
  }

  async function checkLoginStatus() {
    try {
      const response = await fetch(`${API_BASE_URL}/profile`, { method: 'GET', credentials: 'include' });
      if (!response.ok) throw new Error('Not authenticated');
      const data = await response.json();
      updateAuthState(true, data.user);
    } catch (error) {
      updateAuthState(false);
    }
  }

  // --- AUTH TRIGGER ---
  authTrigger.addEventListener('click', (e) => {
    e.stopPropagation();
    if (isLoggedIn) {
      profileDropdown.classList.toggle('hidden');
    } else {
      authModalBackdrop.classList.remove('hidden');
      showView(loginForm); // Default to login view
      loginForm.reset();
      registerForm.reset();
      verifyForm.reset();
    }
  });

  closeModalBtn.addEventListener('click', () => authModalBackdrop.classList.add('hidden'));
  authModalBackdrop.addEventListener('click', (e) => { if (e.target === authModalBackdrop) authModalBackdrop.classList.add('hidden'); });

  // Form switching links
  const authFlow = document.getElementById('authFlow');
  if (authFlow) {
    authFlow.addEventListener('click', (e) => {
      // Check if the clicked element has the ID 'showRegisterLink'
      if (e.target.id === 'showRegisterLink') {
        e.preventDefault();
        showView(registerForm);
      }
      // Check if the clicked element has the ID 'showLoginLinkFromRegister'
      if (e.target.id === 'showLoginLinkFromRegister') {
        e.preventDefault();
        showView(loginForm);
      }
    });
  }

  // --- FORM SUBMISSIONS ---

  // Step 1: Register
  registerForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    showMessage('');
    const registerBtn = registerForm.querySelector('button');
    registerBtn.disabled = true;
    registerBtn.textContent = i18next.t('auth.registeringButton');

    currentEmailForVerification = document.getElementById('registerEmail').value;
    const payload = {
      firstName: document.getElementById('firstNameInput').value,
      lastName: document.getElementById('lastNameInput').value,
      email: currentEmailForVerification,
      password: document.getElementById('registerPassword').value
    };

    try {
      const response = await fetch(`${API_BASE_URL}/auth/register`, {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data = await response.json();
      if (!response.ok) throw new Error(data.message);

      // On success, move to the OTP verification step
      document.getElementById('otpEmailDisplay').textContent = currentEmailForVerification;
      showView(verifyForm);

    } catch (err) {
      showMessage(err.message, true);
    } finally {
      registerBtn.disabled = false;
      registerBtn.textContent = i18next.t('auth.registerButton');
    }
  });

  // Step 2: Verify OTP
  verifyForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    showMessage('');
    const verifyBtn = verifyForm.querySelector('button');
    verifyBtn.disabled = true;
    verifyBtn.textContent = i18next.t('auth.verifyingButton');

    const payload = {
      email: currentEmailForVerification,
      otp: document.getElementById('otpInput').value
    };

    try {
      const response = await fetch(`${API_BASE_URL}/auth/verify-account`, {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data = await response.json();
      if (!response.ok) throw new Error(data.message);

      // On success, inform the user and switch to the login form
      showMessage(i18next.t('auth.verifySuccess'), false);
      showView(loginForm);

    } catch (err) {
      showMessage(err.message, true);
    } finally {
      verifyBtn.disabled = false;
      verifyBtn.textContent = i18next.t('auth.verifyButton');
    }
  });

  // Step 3: Login
  loginForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    showMessage('');
    const loginBtn = loginForm.querySelector('button');
    loginBtn.disabled = true;
    loginBtn.textContent = i18next.t('auth.loggingInButton');

    const payload = {
      email: document.getElementById('loginEmail').value,
      password: document.getElementById('loginPassword').value
    };

    try {
      const response = await fetch(`${API_BASE_URL}/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(payload)
      });
      const data = await response.json();
      if (!response.ok) throw new Error(data.message);

      updateAuthState(true, data.user); // Login successful
      await syncGuestTasksToServer();

      if (typeof renderWeeklyView === 'function') {
        renderWeeklyView();
      }
    } catch (err) {
      showMessage(err.message, true);
    } finally {
      loginBtn.disabled = false;
      loginBtn.textContent = i18next.t('auth.loginButton');
    }
  });

  // --- Other Listeners (Logout, Password Toggle, etc.) ---
  logoutButton.addEventListener('click', async () => {
    try {
      await fetch(`${API_BASE_URL}/auth/logout`, { method: 'POST', credentials: 'include' });
    } finally {
      updateAuthState(false);
      if (typeof renderWeeklyView === 'function') {
        renderWeeklyView();
      }
    }
  });

  const toggleRegisterPassword = document.getElementById('toggleRegisterPassword');
  toggleRegisterPassword.addEventListener('click', function () {
    const registerPasswordInput = document.getElementById('registerPassword');
    const type = registerPasswordInput.getAttribute('type') === 'password' ? 'text' : 'password';
    registerPasswordInput.setAttribute('type', type);
    document.getElementById('register-eye-open-svg').style.display = (type === 'password') ? 'block' : 'none';
    document.getElementById('register-eye-closed-svg').style.display = (type === 'password') ? 'none' : 'block';
  });

  // --- INITIALIZATION ---
  // checkLoginStatus();

  return { checkLoginStatus };
};

// This is your corrected data-loading function
async function loadTasks(weekId) {
  if (isLoggedIn) {
    // ONLY if logged in, make the API call to the backend.
    try {
      const response = await fetch(`${API_BASE_URL}/api/tasks?weekStart=...&weekEnd=...`, {
        credentials: "include",
      });
      if (!response.ok) {
        // This will catch the 401 and other errors gracefully.
        throw new Error("Failed to fetch tasks from server.");
      }
      return await response.json();
    } catch (error) {
      console.error(error.message);
      return []; // Return an empty array on failure
    }
  } else {
    // If the user is a GUEST, get tasks from localStorage and DO NOT make an API call.
    console.log("Guest mode: Loading tasks from localStorage.");
    return getGuestTasks();
  }
}

// Guest Task Helpers
// -----------------------------
function getGuestTasks() {
  return JSON.parse(localStorage.getItem("guestTasks")) || [];
}

function saveGuestTasks(tasks) {
  localStorage.setItem("guestTasks", JSON.stringify(tasks));
}

// Add this new function alongside your other task functions
async function syncGuestTasksToServer() {
  const guestTasks = getGuestTasks();

  // If there are no tasks to sync, do nothing
  if (!guestTasks || guestTasks.length === 0) {
    console.log("No guest tasks to sync.");
    return;
  }

  console.log(`Syncing ${guestTasks.length} guest tasks to the server...`);

  try {
    // We assume your backend has a route like '/api/tasks/batch-create'
    // that can accept an array of tasks.
    const response = await fetch(`${API_BASE_URL}/api/tasks/batch-create`, {
      method: "POST",
      credentials: "include", // Important for sending the auth cookie
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tasks: guestTasks }),
    });

    if (!response.ok) {
      throw new Error("Failed to sync guest tasks.");
    }

    // If the sync was successful, clear the guest tasks from local storage
    localStorage.removeItem("guestTasks");
    console.log("Guest tasks synced and cleared from localStorage.");

  } catch (error) {
    console.error("Error syncing guest tasks:", error);
    // We don't clear localStorage here so the user doesn't lose their data
    // You could show a message asking them to try again later.
    showMessage("Could not save your guest tasks. Please contact support.", true);
  }
}

// -----------------------------
// Task Functions
// -----------------------------
async function addTask(task) {
  if (isLoggedIn) {
    await fetch(`${API_BASE_URL}/api/tasks`, {
      method: "POST",
      credentials: "include",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(task),
    });
  } else {
    let guestTasks = getGuestTasks();
    guestTasks.push(task);
    saveGuestTasks(guestTasks);
  }
}

async function deleteTask(taskId) {
  if (isLoggedIn) {
    await fetch(`${API_BASE_URL}/api/tasks/${taskId}`, {
      method: "DELETE",
      credentials: "include",
    });
  } else {
    let guestTasks = getGuestTasks();
    guestTasks = guestTasks.filter((t) => t.id !== taskId);
    saveGuestTasks(guestTasks);
  }
}



// : button dropdown
const menuBtn = document.querySelector(".circle-menu");
const dropdown = document.querySelector(".dropdown-content");
const authTrigger = document.getElementById('auth-trigger');
const profileDropdown = document.getElementById('profile-dropdown');

// --- CIRCLE MENU ---
menuBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  profileDropdown.classList.add('hidden');
  dropdown.classList.toggle("show");
});

document.addEventListener("click", (e) => {
  if (!authTrigger.contains(e.target) && !profileDropdown.contains(e.target)) {
    profileDropdown.classList.add("hidden");
  }
  if (!menuBtn.contains(e.target) && !dropdown.contains(e.target)) {
    dropdown.classList.remove("show");
  }
});

// --- Constants and State ---
// It's good practice to keep API URLs and DOM elements at the top.
const calendarListContainer = document.getElementById("calendar-list-container");
const authTriggerBtn = document.getElementById("auth-trigger");

let allCalendars = []; // Store fetched calendars to avoid re-fetching
let selectedCalendarId = null;

// --- Main Logic ---

// This is now the single entry point when the dropdown is clicked.
async function onCalendarDropdownOpen() {
  // Only fetch the list of calendars if we haven't already.
  if (allCalendars.length > 0) {
    return;
  }

  calendarListContainer.innerHTML = "<p>Loading calendars...</p>";
  try {
    const calendars = await fetchCalendars();
    allCalendars = calendars; // Save the fetched calendars

    if (allCalendars.length > 0) {
      // If no calendar is selected, default to the first one.
      selectedCalendarId = allCalendars[0].id;
      renderCalendarList();
      await loadAndRenderTasks(selectedCalendarId);
    } else {
      calendarListContainer.innerHTML = "<p>No calendars found.</p>";
    }
  } catch (err) {
    console.error("Failed to initialize calendars:", err);
    calendarListContainer.innerHTML = "<p>Error loading calendars.</p>";
  }
}

// --- Data Fetching Functions ---

// 1. Fetches the LIST of calendars from the API. Its only job is to get data.
async function fetchCalendars() {
  const token = localStorage.getItem("token"); // Don't forget the token!
  const res = await fetch(`${API_BASE_URL}/api/calendars`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      // CRITICAL: Added Authorization header
      "Authorization": `Bearer ${token}`
    },
    credentials: "include"
  });
  if (!res.ok) {
    throw new Error('Failed to fetch calendars from API');
  }
  return await res.json();
}

// 2. Fetches the TASKS for a single calendar. Its only job is to get data.
async function fetchTasksForCalendar(calendarId) {
  const token = localStorage.getItem("token");
  if (!calendarId) {
    throw new Error("No calendar ID provided.");
  }
  const res = await fetch(`${API_BASE_URL}/api/calendars/${calendarId}/tasks`, {
    headers: {
      "Content-Type": "application/json",
      // CRITICAL: Added Authorization header
      "Authorization": `Bearer ${token}`
    },
    credentials: "include"
  });
  if (!res.ok) {
    throw new Error(`Failed to fetch tasks: ${res.status}`);
  }
  return await res.json();
}


// --- DOM Rendering Functions ---

// Renders the list of calendars. Its only job is to update the DOM.
function renderCalendarList() {
  calendarListContainer.innerHTML = ""; // Clear old list

  allCalendars.forEach(cal => {
    const calDiv = document.createElement("div");
    calDiv.className = "calendar-item";
    calDiv.dataset.calendarId = cal.id; // Use data-attribute for easy access

    if (cal.id === selectedCalendarId) {
      calDiv.classList.add("active");
    }

    calDiv.innerHTML = `
            <span class="calendar-name">${cal.name}</span>
            <small class="calendar-owner">
                ${cal.isOwnedByCurrentUser ? "(You)" : "Shared by " + cal.owner.firstName}
            </small>
        `;

    // Event listener to switch active calendar
    calDiv.addEventListener("click", handleCalendarSelection);
    calendarListContainer.appendChild(calDiv);
  });
}

// Loads and then renders tasks for the selected calendar.
async function loadAndRenderTasks(calendarId) {
  taskContainer.innerHTML = "<p>Loading tasks...</p>"; // Provide user feedback
  try {
    const tasks = await fetchTasksForCalendar(calendarId);

    taskContainer.innerHTML = ""; // Clear "Loading..." message
    if (!tasks.length) {
      taskContainer.innerHTML = "<p>No tasks found in this calendar.</p>";
      return;
    }

    tasks.forEach(task => {
      const taskDiv = document.createElement("div");
      taskDiv.className = "task-item";
      taskDiv.innerText = task.title || "Untitled Task";
      taskContainer.appendChild(taskDiv);
    });
  } catch (err) {
    console.error("Error loading tasks:", err);
    taskContainer.innerHTML = "<p>Could not load tasks.</p>";
  }
}

// --- Event Handlers ---
function getSelectedCalendarId() {
  return selectedCalendarId;
}

// Handles a click on a calendar item efficiently.
async function handleCalendarSelection(event) {
  // 'currentTarget' refers to the div the listener was attached to.
  const clickedCalendarId = event.currentTarget.dataset.calendarId;

  if (clickedCalendarId === selectedCalendarId) {
    return; // Do nothing if the already-active calendar is clicked
  }

  selectedCalendarId = event.currentTarget.dataset.calendarId;

  // More EFFICIENT: Update classes instead of re-rendering the whole list.
  // 1. Remove 'active' from the previously active item
  const oldActive = calendarListContainer.querySelector(".calendar-item.active");
  if (oldActive) {
    oldActive.classList.remove("active");
  }
  // 2. Add 'active' to the newly clicked item
  event.currentTarget.classList.add("active");

  // 3. Load the tasks for the new calendar
  await loadAndRenderTasks(selectedCalendarId);
}

// --- Initial Setup ---
authTriggerBtn.addEventListener("click", onCalendarDropdownOpen);